import com.kotori316.plugin.cf.CallVersionCheckFunctionTask
import com.kotori316.plugin.cf.CallVersionFunctionTask

import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter

plugins {
    id("java")
    id("maven-publish")
    id("signing")
    id("idea")
    id("net.neoforged.gradle.userdev").version("7.0.163")
    id("net.neoforged.gradle.mixin").version("7.0.163")
    id("com.matthewprenger.cursegradle") version("1.4.0")
    id("com.modrinth.minotaur").version("2.+")
    id("com.kotori316.plugin.cf").version("3.+")
}

version = project.modVersion
group = "com.kotori316" // http://maven.apache.org/guides/mini/guide-naming-conventions.html
java.toolchain.languageVersion = JavaLanguageVersion.of(21)

base {
    archivesName = "${project.baseName}-NeoForge-${project.minecraftVersion}"
}

// IDEA no longer automatically downloads sources/javadoc jars for dependencies, so we need to explicitly enable the behavior.
idea {
    module {
        downloadSources = true
        downloadJavadoc = true
    }
}

subsystems {
    parchment {
        minecraftVersion = project.property("parchment_mapping_mc")
        mappingsVersion = project.property("parchment_mapping_version")
    }
}

runs {
    configureEach { net.neoforged.gradle.dsl.common.runs.run.Run run ->
        run.systemProperties.put("forge.logging.markers", "REGISTRIES")
        run.systemProperties.put("forge.logging.console.level", "debug")
    }
    client {
        workingDirectory.set(file("run"))
        systemProperties.put("mixin.debug.export", "true")
        jvmArguments.add("-XstartOnFirstThread")
        modSources.add(project.sourceSets.main)
    }
    gameTestServer {
        workingDirectory.set(file("run-server"))
        systemProperties.put("neoforge.enabledGameTestNamespaces", "${project.property("mod_id")},minecraft")
        modSources.add(project.sourceSets.test)
    }
}

processResources {
    from project(":common").sourceSets.main.resources
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    inputs.property("version", project.version)
    inputs.property("mcVersion", project.property("minecraftVersion"))

    ["fabric.mod.json", "META-INF/mods.toml", "META-INF/neoforge.mods.toml"].forEach { fileName ->
        filesMatching(fileName) {
            expand([
                    "version"  : project.version,
                    "mcVersion": project.property("minecraftVersion"),
            ])
        }
    }
}

repositories {
    mavenCentral()
    maven {
        name = "Kotori316Plugin"
        url = uri("https://maven.kotori316.com/")
        content {
            includeGroup("com.kotori316")
        }
    }
}

dependencies {
    implementation("net.neoforged:neoforge:${project.neo_version}")
    testImplementation("net.neoforged:testframework:${project.neo_version}")
    compileOnly project(":common")
    testImplementation(project(":common"))

    testImplementation(platform("org.junit:junit-bom:${project.property("jupiter")}"))
    testImplementation("org.junit.jupiter:junit-jupiter")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
}

tasks.named("compileJava", JavaCompile).configure {
    source(project(":common").sourceSets.main.allSource)
}

mixin {
    config("${project.mod_id}.mixins.json")
}

// Example for how to get properties into the manifest for reading by the runtime..
jar {
    String vendor = "Kotori316"
    manifest {
        attributes([
                "Specification-Title"     : project.name,
                "Specification-Vendor"    : vendor,
                "Specification-Version"   : "1", // We are version 1 of ourselves
                "Implementation-Title"    : project.name,
                "Implementation-Version"  : project.version.toString(),
                "Implementation-Vendor"   : vendor,
                "Implementation-Timestamp": ZonedDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME),
                "MixinConfigs"            : "${project.mod_id}.mixins.json",
                "Automatic-Module-Name"   : project.mod_id,
        ])
    }
}

jar.finalizedBy("jksSignJar")

tasks.register("jksSignJar") {
    dependsOn("jar")
    boolean executeCondition = project.hasProperty("jarSign.keyAlias") &&
            project.hasProperty("jarSign.keyLocation") &&
            project.hasProperty("jarSign.storePass")
    onlyIf { executeCondition }
    doLast {
        //noinspection HttpUrlsUsage
        ant.signjar(
                jar: jar.archiveFile.get(),
                alias: project.findProperty("jarSign.keyAlias") ?: "",
                keystore: project.findProperty("jarSign.keyLocation") ?: "",
                storepass: project.findProperty("jarSign.storePass") ?: "",
                sigalg: "Ed25519",
                digestalg: "SHA-256",
                tsaurl: "http://timestamp.digicert.com",
        )
    }
}

tasks.register('srcJar', Jar) {
    from sourceSets.main.allSource
    archiveClassifier.set("sources")
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

// Tell the artifact system about our extra jars
artifacts {
    archives srcJar
}

signing {
    sign(publishing.publications)
    sign(tasks.jar, tasks.srcJar)
}

curseforge {
    apiKey = project.findProperty("curseforge_additional-enchanted-miner_key") ?: System.getenv("CURSE_TOKEN") ?: ""
    project {
        id = "289078"
        changelogType = "markdown"
        changelog = "For Minecraft ${project.minecraftVersion} with NeoForge ${project.neo_version}"
        addGameVersion(project.minecraftVersion)
        addGameVersion("NeoForge")
        releaseType = "release"
        mainArtifact jar
    }
    options {
        curseGradleOptions.debug = !Boolean.parseBoolean(project.releaseMode) // defaults to false
        javaVersionAutoDetect = false
    }
}

modrinth {
    token.set((project.findProperty("modrinthToken") ?: System.getenv("MODRINTH_TOKEN") ?: "") as String)
    projectId = "auto-planter"
    versionType = "release"
    versionName = "${project.version}-neoforge"
    versionNumber.set(project.version.toString())
    uploadFile = tasks.jar
    getAdditionalFiles().set([
            tasks.srcJar,
    ])
    getGameVersions().set([project.minecraftVersion])
    getLoaders().set(["neoforge"])
    changelog = "For Minecraft ${project.minecraftVersion} with NeoForge ${project.neo_version}"
    debugMode = !Boolean.parseBoolean(project.releaseMode)
    dependencies {
    }
}

publishing {
    if (Boolean.parseBoolean(project.releaseMode)) {
        repositories {
            def u = project.findProperty("maven_username") as String ?: System.getenv("MAVEN_USERNAME") ?: ""
            def p = project.findProperty("maven_password") as String ?: System.getenv("MAVEN_PASSWORD") ?: ""
            if (u != "" && p != "") {
                maven {
                    name = "kotori316-maven"
                    // For users: Use https://maven.kotori316.com to get artifacts
                    url = uri("https://maven2.kotori316.com/production/maven")
                    credentials {
                        username = u
                        password = p
                    }
                }
            }
        }
    }
    publications {
        mavenJava(MavenPublication) {
            artifactId = project.archivesBaseName.toLowerCase()
            from components.java
            artifact(tasks.srcJar)
            pom {
                name = archivesBaseName
                description = "AutoPlanter for Minecraft ${project.minecraftVersion} and NeoForge ${project.neo_version}"
                url = "https://github.com/Kotori316/AutoPlanter"
                packaging = "jar"
            }
        }
    }
}

boolean hasGpgSignature = project.hasProperty("signing.keyId") &&
        project.hasProperty("signing.password") &&
        project.hasProperty("signing.secretKeyRingFile")

tasks.withType(Sign).configureEach {
    it.onlyIf {
        hasGpgSignature
    }
}

tasks.withType(AbstractPublishToMaven).configureEach {
    if (hasGpgSignature) {
        it.dependsOn(":neoforge:signJar")
        it.dependsOn(":neoforge:signSrcJar")
    }
}

tasks.register("registerVersion", CallVersionFunctionTask.class) {
    functionEndpoint = readVersionFunctionEndpoint(project)
    gameVersion = project.findProperty("minecraftVersion")
    platform = "neoforge"
    platformVersion = project.findProperty("neo_version")
    modName = project.findProperty("mod_id")
    changelog = "For ${project.findProperty("minecraftVersion")}"
    homepage = "https://modrinth.com/mod/auto-planter"
}

tasks.register("checkReleaseVersion", CallVersionCheckFunctionTask.class) {
    gameVersion = project.findProperty("minecraftVersion")
    platform = "neoforge"
    modName = project.findProperty("mod_id")
    version = project.version
    failIfExists = Boolean.parseBoolean(System.getenv("FAIL_IF_EXISTS"))
}
